---
layout: post
title: x86_x64 assembly
tags: [Reversing, Computer science] 
comments: true
---  

## Process Memory
우리가 작성한 소스코드는 컴파일 + 링크 과정을 거치고 최종적으로 실행 가능한 프로그램이 되게 된다.  
![compile](/images/post/2019-09-09-compile.png)

실행 가능한 프로그램은 실행이 되기 전에 메모리에 적재가 되는데 이를 Load라고 한다.
CPU는 메모리에 올라간 프로그램의 명령어를 가져와서 해석하고, 실행하게 된다.
이렇게 메모리에 올라가서 실행된 프로그램을 프로세스라고 한다.  
(너무 쉽게 설명했지만 사실은 매우 복잡하다.)  

**즉 프로그램이 컴퓨터에 저장된 (실제로는 파일시스템에 저장된) 파일이라면,  
프로세스는 메모리에 올라가 CPU에 의해 실행되고 있는 것을 말한다.**

이 때 32bit 프로그램은 프로세스가 될 때 4GB(2의 32승)의 메모리를 할당받아 사용하고,  
64bit 프로그램에서는 16TB(2의 64승)의 메모리를 할당받게 된다.  

프로세스가 할당 받은 메모리는 다음과 같은 구조를 같게 된다.  
![memory](/images/post/2019-09-09-memory.png)  
기본적으로 stack 영역으로 갈 수록 높은 주소(0xffff~)이고 Code 영역으로 갈 수록 낮은 주소(0x0000~)가 된다.  
* .code(.text) : CPU에 의해 실행되는 명령어들이 모여 있는 섹션으로 모든 명령어는 기계어로 표현되어 있다. const keyword 데이터도 해당 영역에 저장된다.
* .data : 초기화가 된 전역변수 및 static keyword 변수들이 저장된다.
* .bss : 초기화가 되지 않은 전역변수 및 static keyword 변수들이 저장된다.
* .heap : 동적할당 및 해제 시 사용되는 섹션이며 낮은 주소에서 높은 주소로 메모리가 동적할당된다.
* .stack : 함수에서 사용되는 지역변수들이 저장되는 섹션이며, FILO(Frist In, Last Out)방식으로 데이터를 저장한다. 높은 주소에서 낮은 주소로 데이터를 저장한다.

.code, .data, .bss는 일반적으로 compile time 때 크기가 결정되고, .heap, .stack은 runtime 때 크기가 결정된다.



## Register
CPU에서는 메모리에 적재된 프로세스로부터 메모리에 있는 코드와 저장된 변수들을 읽어들여서 실행을 해야한다. 이 때 사용되는 것이 레지스터(Register)이다.  
레지스터는 CPU에서 필요한 데이터를 메모리에서 가져와 저장하여 CPU가 빠르게 연산할 수 있도록 도와주는 역활을 한다.  
그렇기 때문에 메모리보다 크기는 작지만 CPU에서 바로바로 접근이 가능하므로, 고속연산이 가능하다.   
이 레지스터는 하드웨어 의존성을 지니게 된다. 즉, CPU제조사 마다 레지스터의 종류와 역활은 다르다.  
컴퓨터나 노트북에 많이 사용되는 CPU 제조사는 AMD와 Intel인데, 두 제조사 모두 x86_64 아키텍처를 채용하므로, 동일한 레지스터를 사용한다.  
(이렇게 된 거에는 비하인드 스토리가 있는데 찾아보면 나름 재밌다(?))  
![register](/images/post/2019-09-09-register.jpg) 
  
레지스터는 목적에 따라 다음과 같이 세분화 된다.
* General Purpose Register  
    범용 레지스터라고 하며, 총 16개의 레지스터가 존재한다. 레지스터 별로 용도가 있지만 **경우에 따라 다르게 사용될수도 있다.**
    - RAX : 누산기 레지스터라고도 하며 가장 많이 사용되는 레지스터이다.  산술연산에 필요한 데이터를 저장하거나, 함수의 반환값을 저장한다.
    - RBX : 베이스 레지스터라고도 하며, 특정 주소값을 저장하는 용도이지만 필요에 따라서는 데이터도 저장한다.
    - RCX : 반복문 카운터로 사용되는 레지스터이다.
    - RDX : 데이터를 저장하는 용도의 레지스터이다.
    - RSI : 문자열을 처리할 때, 근원지가 되는 문자열의 주소를 저장한다.
    - RDI : RSI와 함께 문자열을 처리할 때 사용되며, 목적지에 해당하는 주소의 주소를 저장한다.
    - RSP : 스택 구조에서 스택의 최상위(top)을 가르키며, push와 pop에 의해 이동하게 된다.
    - RBP : 현재 함수의 베이스 주소를 가르키며, 함수 호출이 되고 나면 이동하지 않는다.
* Instruction Pointer  
컴퓨터 구조에서 Program Counter이며, 다음 실행될 코드 영역의 주소를 가르키고 있다.

* Multimedia extension and Floating points Register  
펜티엄 프로세서에서부터 지원하며, 주로 멀티미디어 데이터나 부동소수점 연산을 처리하기 위해 사용되는 레지스터 모음이다. IA-32일 때, MMX 명령어 세트는 부동소수점 데이터와 SIMD 데이터를 동시에 작동시킬 수 없었으며, 오직 정수 연산만을 지원하는 단점이 있었다.

* Streaming SIMD Extensions Register
intel이 위의 MMX 명령어 셋을 문제점을 해결하기 위해 만든 명령어 세트에 사용되는 레지스터이며 128bit 크기를 가진다. 펜티엄 3시리즈부터 도입되었다고 한다.

* Flag Register
 상태 레지스터라고도 하며, 각종 산술연산의 결과에 대한 상태 값을 알려준다. 주로 조건문에서 분기의 기준이 되기도 한다.


32bit에서는 범용 레지스터의 크기는 모두 4바이트(32bit)이고, 64bit에서는 8바이트(64bit) 크기를 갖게된다. 이 때문에 위에 설명한 32bit 프로세스와 64bit 프로세스가 서로 다른 크기의 메모리를 사용하게 된다.


## Assembly
기계어를 그나마 사람이 보기 쉽게 만든 프로그래밍 언어로, 기계어와 1:1로 대응된다는 특징을 지닌다. 프로그래밍 언어론적으로는 기계어와 함께 Low-level 언어로 구분하며, 하드웨어 의존성을 지닌다. 즉 아키텍처가 다르면, 지원하는 어셈블리어도 다르다.  
어셈블리어는 명령어와 오퍼랜드로 구성되며, 명령어는 CPU가 해석하여 수행해야하는 작동 코드를 의미하고 오퍼랜드는 해당 명령의 수행대상이다.  
오퍼랜드는 레지스터, 특정 값, 메모리의 주소가 될 수 있다.
크게 문법으로 2개가 있는데 intel 문법과 AT&T문법으로 나뉜다.  
![AT&T](/images/post/2019-09-09-att.png) 
![intel](/images/post/2019-09-09-intel.png) 

위의 이미지가 AT&T문법이고, 아래가 intel 문법이다.  
AT&T는 2개의 오퍼랜드를 사용시 왼쪽이 Source, 오른쪽이 Destination이고,  
intel은 왼쪽이 Destination, 오른쪽이 Source가 되게 된다.  
또한 AT&T는 메모리에 대한 오퍼랜드에 대한 표기가 소괄호() 이지만, intel은 대괄호[]를 사용한다.

_(난 intel이 익숙해서 intel로 포스트 작성할 예정 ㅎㅎ;)_

어셈블리 언어는 **매우매우** 많기때문에 대표적인거는 다음과같다.   
- push %reg : 스택의 최상위에 reg의 값을 저장하고, RSP를 증가시킨다.  
- pop %reg : 스택의 최상위에 있는 값을 reg에 저장하고, RSP를 감소시킨다.  
- mov reg/addr, val/reg/addr : 데이터를 복사한다.  
- lea reg, addr : 주소를 복사한다.  
- cmp : 값을 비교하는 명령어이며, 비교 후 특정 플래그를 셋팅하여 분기문에 사용된다.  
- jmp : 오퍼랜드의 주소로 이동하여 명령어를 계속 실행한다.  
- call : 호출된 코드의 다음 주소를 스택에 저장하고, 해당 주소로 이동하여 명령어를 실행한다.  
- ret : 스택의 RSP가 가르키고 있는 곳으로 이동하고 RSP를 증가시킨다.  




* ref  
    리버싱의 핵심원리  
    x86_64 register chart : http://forum.codecall.net/topic/52853-x86-64-register-chart/
